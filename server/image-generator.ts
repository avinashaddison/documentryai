import Replicate from "replicate";
import fs from "fs";
import path from "path";
import https from "https";
import http from "http";

const OUTPUT_DIR = path.join(process.cwd(), "generated_assets", "images");

if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

function getReplicateClient(): Replicate {
  const token = process.env.REPLICATE_API_TOKEN;
  if (!token) {
    throw new Error("REPLICATE_API_TOKEN is not configured. Please add your Replicate API token.");
  }
  return new Replicate({ auth: token });
}

async function downloadImage(url: string, filepath: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(filepath);
    const protocol = url.startsWith("https") ? https : http;
    
    protocol.get(url, (response) => {
      if (response.statusCode === 302 || response.statusCode === 301) {
        const redirectUrl = response.headers.location;
        if (redirectUrl) {
          downloadImage(redirectUrl, filepath).then(resolve).catch(reject);
          return;
        }
      }
      
      response.pipe(file);
      file.on("finish", () => {
        file.close();
        resolve(filepath);
      });
    }).on("error", (err) => {
      fs.unlink(filepath, () => {});
      reject(err);
    });
  });
}

export interface ImageGenerationResult {
  success: boolean;
  imagePath?: string;
  imageUrl?: string;
  error?: string;
  model?: string;
  prompt?: string;
}

export async function generateImage(
  prompt: string,
  options: {
    model?: "flux-1.1-pro" | "flux-schnell" | "ideogram-v3-turbo";
    aspectRatio?: "16:9" | "9:16" | "1:1" | "4:3" | "3:4";
    outputFormat?: "webp" | "png" | "jpg";
    projectId?: number;
    sceneId?: string;
  } = {}
): Promise<ImageGenerationResult> {
  const {
    model = "flux-1.1-pro",
    aspectRatio = "16:9",
    outputFormat = "webp",
    projectId,
    sceneId,
  } = options;

  if (!projectId || !sceneId) {
    return {
      success: false,
      error: "Both projectId and sceneId are required for image generation",
      model,
      prompt,
    };
  }

  let replicate: Replicate;
  try {
    replicate = getReplicateClient();
  } catch (error: any) {
    return {
      success: false,
      error: error.message,
      model,
      prompt,
    };
  }

  try {
    let output: any;
    let modelId: `${string}/${string}`;

    const cinematicPrompt = `${prompt}, cinematic photography, professional lighting, 8K ultra HD quality, dramatic atmosphere, documentary style, photorealistic`;

    if (model === "flux-1.1-pro") {
      modelId = "black-forest-labs/flux-1.1-pro" as const;
      output = await replicate.run(modelId, {
        input: {
          prompt: cinematicPrompt,
          aspect_ratio: aspectRatio,
          output_format: outputFormat,
          output_quality: 90,
          safety_tolerance: 2,
          prompt_upsampling: true,
        },
      });
    } else if (model === "flux-schnell") {
      modelId = "black-forest-labs/flux-schnell" as const;
      output = await replicate.run(modelId, {
        input: {
          prompt: cinematicPrompt,
          aspect_ratio: aspectRatio,
          output_format: outputFormat,
          go_fast: true,
          num_outputs: 1,
        },
      });
    } else {
      modelId = "ideogram-ai/ideogram-v2-turbo" as const;
      output = await replicate.run(modelId, {
        input: {
          prompt: cinematicPrompt,
          aspect_ratio: aspectRatio === "16:9" ? "16:9" : aspectRatio === "9:16" ? "9:16" : "1:1",
          resolution: "1024x576",
        },
      });
    }

    const imageUrl = Array.isArray(output) ? output[0] : output;
    
    if (!imageUrl) {
      return { success: false, error: "No image generated by the model", model, prompt };
    }

    const filename = `${projectId}_${sceneId}.${outputFormat}`;
    const filepath = path.join(OUTPUT_DIR, filename);

    try {
      await downloadImage(imageUrl as string, filepath);
      
      if (!fs.existsSync(filepath)) {
        return {
          success: false,
          error: "Image download failed - file not saved",
          model,
          prompt,
        };
      }

      const stats = fs.statSync(filepath);
      if (stats.size === 0) {
        fs.unlinkSync(filepath);
        return {
          success: false,
          error: "Image download failed - empty file",
          model,
          prompt,
        };
      }
    } catch (downloadError: any) {
      return {
        success: false,
        error: `Failed to download image: ${downloadError.message}`,
        model,
        prompt,
      };
    }

    return {
      success: true,
      imagePath: filepath,
      imageUrl: `/generated_assets/images/${filename}`,
      model: modelId,
      prompt: cinematicPrompt,
    };
  } catch (error: any) {
    console.error("Image generation error:", error);
    const userSafeMessage = error.message?.includes("API") || error.message?.includes("token")
      ? "Image generation service unavailable. Please check API configuration."
      : "Failed to generate image. Please try again.";
    return {
      success: false,
      error: userSafeMessage,
      model,
      prompt,
    };
  }
}

export async function generateSceneImages(
  scenes: Array<{
    sceneNumber: number;
    imagePrompt: string;
    chapterNumber: number;
  }>,
  projectId: number,
  options: {
    model?: "flux-1.1-pro" | "flux-schnell" | "ideogram-v3-turbo";
    onProgress?: (completed: number, total: number, scene: any) => void;
  } = {}
): Promise<Array<ImageGenerationResult & { sceneNumber: number; chapterNumber: number }>> {
  const results: Array<ImageGenerationResult & { sceneNumber: number; chapterNumber: number }> = [];
  const { model = "flux-1.1-pro", onProgress } = options;

  for (let i = 0; i < scenes.length; i++) {
    const scene = scenes[i];
    const sceneId = `ch${scene.chapterNumber}_sc${scene.sceneNumber}`;
    
    const result = await generateImage(scene.imagePrompt, {
      model,
      aspectRatio: "16:9",
      projectId,
      sceneId,
    });

    results.push({
      ...result,
      sceneNumber: scene.sceneNumber,
      chapterNumber: scene.chapterNumber,
    });

    if (onProgress) {
      onProgress(i + 1, scenes.length, { ...scene, ...result });
    }

    if (i < scenes.length - 1) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }

  return results;
}

export async function generateChapterImages(
  chapterData: {
    chapterNumber: number;
    scenes: Array<{
      sceneNumber: number;
      imagePrompt: string;
    }>;
  },
  projectId: number,
  options: {
    model?: "flux-1.1-pro" | "flux-schnell" | "ideogram-v3-turbo";
    onProgress?: (completed: number, total: number, scene: any) => void;
  } = {}
): Promise<Array<ImageGenerationResult & { sceneNumber: number }>> {
  const scenes = chapterData.scenes.map((s) => ({
    ...s,
    chapterNumber: chapterData.chapterNumber,
  }));
  
  const results = await generateSceneImages(scenes, projectId, options);
  
  return results.map(({ chapterNumber, ...rest }) => rest);
}

export const imageGenerator = {
  generateImage,
  generateSceneImages,
  generateChapterImages,
};
